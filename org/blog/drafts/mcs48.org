#+TITLE: MCS-48

* Background

I always wanted to learn [[https://en.wikipedia.org/wiki/Assembly_language][Assembly]] language. But, having looked at some of the niches (reversing/performance optimization) of current or past applications didn't look too attractive.

That is until some years back when I watched Ben Eater's video series on "8-bit breadboard computers" and more precisely [[https://www.youtube.com/watch?v=LnzuMJLZRdU&list=PLowKtXNTBypFbtuVMUVXNR0z1mu7dp7eH][his 6502 series]]. Where he builds a computer, the old-school way, starting from a 6502 CPU DIP chip, with no code or Operative System to begin with. Adding periphericals one at the time. Without sparing implementation details.

Well, I don't own a 6502. But ... I managed to scavange a 8042 from an old motherboard!

"A 8042?" I hear you say. YES!. It's a MCU (Microcontroller) (aka a CPU+ROM+RAM) with the peculiarity that it can also act as a CPU too, by reading a program from an external ROM.

* The Hardware
** MCU

Is an 80C42, a mcs-48 chip made by NEC. As with any of the family, it has the peculiarity that it uses the same physical pins for r/w data and for addressing (D0-D7).

Some Extra notes to not forget:
- SS# should be tied to V+ when not used.
- different RD#(8) and WR#(10) are inputs from the _master chip_ to enable either, not probes like in 8048
- new A_0(9) input from the _master chip_ to indicate if it is tranfering data or a command
- new SYNC(11) output clock signal which occurs once per cycle

#+ATTR_ORG: :width 200
[[./images/mcs48-80c42-pinout.png]] [[./images/mcs48-74373.png]] [[./images/sst29-pinout.jpg]]

- INT# -> CS#
- PSEN# -> A_0
- ALE -> SYNC

** Address Latch
A 74373. We need this to mediate between the EEPROM and the MCU to toggle depending on wether we are giving an address or fetching some data from it.
#+ATTR_ORG: :width 120
[[./images/mcs48-74373.png]]
** EEPROM
A SSTEE010-150.
#+ATTR_ORG: :width 200
[[./images/sst29-pinout.jpg]]

* Blink
** ASM

We start with some book keeping.

#+begin_src asm
        .ifdef  .__.CPU. ; if we are using as8048 this is defined
        .8041
        .area   CODE    (ABS)
        .endif           ; .__.CPU.
#+end_src

CPU starts reading at address zero (0x0). We put there a jump to where is our program. Skipping some reserve addresss for other operations.

#+begin_src asm
        .org 0x0
reset:
        jmp entry
#+end_src

Our Program.

#+begin_src asm
        .org 0x10
entry:
        mov  A,    #0x0A ; 00001010
        outl P2,   A
        call delay

        mov  A,    #0x15 ; 00010101
        outl P2,   A
        call delay

        jmp  entry       ; repeat main loop
#+end_src

Finally the definition of ~delay~. Basically 2 nested loops with ~nop~ on it's deepest level.

#+begin_src asm
delay:  mov  R0, #255   ; init outer loop counter
delay2: mov  R1, #255   ; init inner loop counter
delay1:
        nop
        nop
        nop
        nop
        djnz R1, delay1 ; dec inner count, continue if not zero
        djnz R0, delay2 ; dec outer count, continue if not zero
        ret             ; return to caller
#+end_src

** The ROM output

04 = JMP <address>

#+CAPTION: output of *hd* on blink.rom
#+begin_src
  00000000  04 10 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
  00000010  23 0a 3a 14 1c 23 15 3a  14 1c 04 10 b8 ff b9 ff  |#.:..#.:........|
  00000020  00 00 00 00 e9 20 e8 1e  83 00 00 00 00 00 00 00  |..... ..........|
  00000030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
  *
  000003f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 9e  |................|
  00000400
#+end_src

* Confirming the CPU is doing what is supposed to do

So here is the image.

#+begin_src sh
$ xxd blink.rom
00000000: 1535 0410 0000 0000 0000 0000 0000 0000  .5..............
00000010: 235f 3a14 1c23 af3a 141c 0410 b955 b863  #_:..#.:.....U.c
00000020: 0000 e820 e91e 8300 0000 0000 0000 0000  ... ............
00000030: 0000 0000 0000 0000 0000 0000 0000 0000  ................
...
#+end_src

** Try 1

And here is some ~Serial~ debug output with the address, data in hexadecimal, and data in bits.

#+begin_src haskell
0000 1a 0001 1010
0001 3a 0011 1010
0002 08 0000 1000
0003 10 0001 0000
#+end_src

We start at address 0x00, and we advance one byte at the time. That seems good.

#+begin_src haskell
0010 23 0010 0011
0011 5f 0101 1111
0012 35 0011 0101
#+end_src

Woah there, we jumped to address 10 (?). Oh right, the ~jmp entry~.

#+begin_src haskell
07ff 00            -- ???
#+end_src

Ok, some random (?) reading.

#+begin_src haskell
0013 18 0001 1000
0014 1c 0001 1100
001c b6 1011 0110
001d 5a 0101 1010
001e b4 1011 0100
001f 63 0110 0011
#+end_src

Wait something is wrong here. The second nibble of data is not always matching the expected data in memory.

For example the first reading, was:

#+begin_src haskell
0000 1a
#+end_src

But it should have been:

#+begin_src haskell
0000 15
#+end_src

Let's check the cables....yup..I got the wiring of this improvised sniffer wrong. Fixing...

But before that let's see a bit more.

#+begin_src haskell
0020 00
0021 00
0022 e4 1110 0100
0023 20 0010 0000

0020 00
0021 00
0022 e4
0023 20
#+end_src

Ok we are looping.

** Try 2

#+begin_src haskell
0000 15
0001 35
0002 04
0003 10
0010 23
0011 5f
0012 3a
07ff 00  -- ???
0013 14
0014 1c
001c b9
001d 55
001e b8
001f 63

0020 00
0021 00
0022 e8
0023 20

0020 00
#+end_src

Ok much better. But, this is looping too much.
** Try 3

#+begin_src sh
$ hd blink.rom
00000000: 1535 0410 0000 0000 0000 0000 0000 0000  .5..............
00000010: 235f 3a14 1c23 af3a 141c 0410 0000 0000  #_:..#.:........
00000020: 8300 0000 0000 0000 0000 0000 0000 0000  ................
00000030: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000040: 0000 0000 0000 0000 0000 0000 0000 0000  ................
#+end_src

#+begin_src haskell
00: 15
01: 35
02: 04
03: 10

10: 23
11: 5f
12: 3a
ff: 00 -- ?
13: 14
14: 1c

1c: 00
1d: 00
1e: 00
1f: 00
20: 83
ff: 00 -- ?

15: 23
16: af
17: 3a
ff: 00 -- ?
#+end_src
