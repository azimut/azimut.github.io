#+TITLE: Arduino: How (NOT) to kill an EEPROM (Part 2)
#+DATE: <2025-04-18 vie>
#+OPTIONS: toc:nil

After repeated failures trying to write to the EEPROM. I am back to square one. But this time armed with better a better sense of what I should avoid (i hope).

* Journal
** Stab #1

So...I looked around and I found a [[https://www.youtube.com/watch?v=2jhTEAkjlpY][video]] that talks about EEPROM memory protection. In particular it mentions problems that might arise with the timings of the SDP commands.

It says that there is a tight window to issue the commands. And Arduino might struggle using DigitalWrite().

Looking back at the [[https://github.com/MustBeArt/29EE010-Programmer][code]] that I mentioned before that disables the SDP. The Teensy 3.5 they used has a clock speed of 120MHz, while my Arduino's have 16MHz.

Video offers 2 solutions. 1) write your arduino code to use [[https://docs.arduino.cc/retired/hacking/software/PortManipulation/][ports]] with some [[https://docs.arduino.cc/learn/programming/bit-math/][bit-math]] 2) or use a [[https://github.com/TomNisbet/TommyPROM][project]] that already uses it

Uploader didn't try either and used a commercial EEPROM programmer.

** Stab #2

Even better, project author has some [[https://github.com/TomNisbet/TommyPROM/tree/master/unlock-ben-eater-hardware][alternative code]] that uses Ben Eater's code as base.

...

And it doesn't work, i get reads of all "0xFF" but memory looks like usual when using regular code.

** Stab #3

Let's try understanding what it is doing.

Looking at some other [[https://github.com/slu4coder/SST39SF010-FLASH-Programmer/blob/main/Arduino_SST39SF0x0/Arduino_SST39SF0x0.ino][code]] mentioned before, the one that is used on FLASH memories. It seems it uses Arduino ports too. So, even if want to give up on this EEPROM due timings, looks like I would need port's speed to work with FLASH memories.

** Stab #4 - about port registers

- Someone wrote an abstraction [[https://github.com/ArminJo/digitalWriteFast][library]] for them using macros.

*** Port registers

- [[https://docs.arduino.cc/retired/hacking/software/PortManipulation/][Arduino docs]]
- 8 bit wide, each one
- 3 ports, some bits/pins are not usable
  |---+--------+------|
  |   |  <c>   |      |
  | D | D0-D7  | 0,1* |
  | B | D8-D13 | 6,7  |
  | C |  A0-5  | 6,7  |
  |---+--------+------|
  - D0: aka RX set as 0=input
  - D1: aka TX set as 1=output
- 3 registers for each port
  |------+----+--------------------------------------|
  | DDR  | rw | configure direction 0=INPUT 1=OUTPUT |
  | PORT | rw | controls LOW/HIGH                    |
  | PIN  | r  | reads INPUT ins                      |
  |------+----+--------------------------------------|

** Stab #5 - ðŸŽ‰ Success! (kinda)

After fixing more wiring and realizing that in order to make code that handles port work correctly i need to respect the original pin position (duh!). I got to write somethin.

#+begin_src
000:  ff ff ee ff ff ff ff ff   ff ff ff ff ff ff ff ff
010:  ff ff ff ff ff ff ff ff   ff ff ff ff ff ff ff ff
...
0e0:  ff ff ff ff ff ff ff ff   ff ff ff ff ff ff ff ff
0f0:  ff ff ff ff ff ff ff ff   ff ff ff ff ff ff ff bb
#+end_src

Those *ff* were written (i think but i am not 100% sure, such is my mess with wiring) by the script i found, but only once. Then It stopped working.

It did however:
- disabled the software protection.
- still works to write a byte, *bb* in this case. It is suppose to write a lot more but I can only get it to write one

Similarly, that *ee* is written by my dumb slow digitalWrite() code. But also with this code I can only write 1 byte per run.

Timings timings timings....

** Stab #5.5

Just some thoughts. Moving outside the IDE helped. In particular I like the current setup switching between uploading my dumb code and the fast port based code for the same pinouts. That way I blame of why something is not working is less abstract.

** Stab #6 - The Good Ending

So, after some weird lectures and even weirder succesful-ish writes. I fixed some wirings and...it works!

#+begin_src
000:  41 42 43 44 45 46 47 48   01 02 04 08 10 20 40 80
010:  7f bf df ef f7 fb fd fe   00 ff 55 aa 30 31 32 33
020:  ea ea ea ea ea ea ea ea   ea ea ea ea ea ea ea ea
030:  ea ea ea ea ea ea ea ea   ea ea ea ea ea ea ea ea
040:  ea ea ea ea ea ea ea ea   ea ea ea ea ea ea ea ea
#+end_src

Which is exactly the test pattern given by TommyPROM.

#+begin_src c
  byte data[] = {
      'A',  'B',  'C',  'D',  'E',  'F',  'G',  'H',
      0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
      0x7f, 0xbf, 0xdf, 0xef, 0xf7, 0xfb, 0xfd, 0xfe,
      0x00, 0xff, 0x55, 0xaa, '0',  '1',  '2',  '3'
  };
#+end_src

Only that I am using an Arduino Mega for this. While their code seems to only been able to unlock the writes. Whatever the case. It is done!. Now to try that 8042.

* Source

This is the final code that I use to write the EEPROM using an arduino Mega heavily based on TommyPROM version of Ben Eater's code.

#+INCLUDE: "./sst29-mega.ino" src arduino
