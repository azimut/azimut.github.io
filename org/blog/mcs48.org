#+TITLE: Retrocomputing: MCS-48 Intro
#+DATE: <2025-07-20 dom>
#+KEYWORDS: assembly, mcs-48, intel 8042, nec 80c42, eeprom, arduino

* Background

I've always wanted to learn to program in [[https://en.wikipedia.org/wiki/Assembly_language][Assembly]]. But, having looked at some of it's niches (reversing, performance programming) they didn't look too attractive to me.

That is until some years back when I watched Ben Eater's video series on [[https://www.youtube.com/playlist?list=PLowKtXNTBypGqImE405J2565dvjafglHU]["8-bit breadboard computers"]] and the more close to the topic of this post his [[https://www.youtube.com/watch?v=LnzuMJLZRdU&list=PLowKtXNTBypFbtuVMUVXNR0z1mu7dp7eH]["Build a 65c02-based computer from scratch"]]. Where he builds a computer the old-school way, starting from a 6502 CPU DIP chip, with no code or Operative System to begin with. Adding software support for periphericals one at the time.

Well, I don't own a 6502. But ... I managed to scavange a 8042 from an old motherboard!

#+ATTR_HTML: :width 400
#+CAPTION: NEC's UPD80C42
[[./images/mcs48-80c42-photo.jpg]]

"A 8042?" I hear you say. YES!. It's a MCU (Microcontroller) (aka a CPU+ROM+RAM) with the peculiarity that it can also act as a CPU, by reading a program from an external ROM.

* Hardware
** MCU

The 80C42, from the Intel's MCS-48 family of chips, was made by NEC.

This variant was intended to work as a slave MCU, so many of it's pins are supposed to receive orders from it's master. But can work for our needs.

#+CAPTION: 8042 pinout
#+ATTR_ORG: :width 200
[[./images/mcs48-80c42-pinout.png]]

** EEPROM

Now we need a place to put our program. Since the MCU internal ROM is programable ONLY by using a special programer, that uses a different supply voltages. We are going to use an external EEPROM.

A SSTEE010-150.

#+ATTR_HTML: :width 300
#+ATTR_ORG: :width 200
[[./images/sst29-pinout.jpg]]

** Wiring

Among the few resources online, there is [[https://devster.monkeeh.com/z80/upi42/][this one]], where it describes 2 different ways to setup this chip for external EEPROM access.
1) Connect directly the CPU and the EEPROM
2) Connect indirectly the CPU through a 74374, a positive edge flip-flop. This gives you access to IO ports on downward SYNC cycles.

For this blog entry I will use 1)

#+CAPTION: wiring for external ROM access
[[./images/mcs48-wiring.jpeg]]

* Programming: Blink LED
** Background

Programming, in this chip means: Writting bytecode into the EEPROM. That then the 8042 can read an interpret as instructions.

#+CAPTION: example opcodes, with their HEX bytecode
[[./images/mcs48-opcodes.png]]

These are some examples of opcodes with their correspont bytecodes that i took from "MCS-48 Assembly Language Reference Card".

This means if I put ~0xF8~ on a EEPROM memory address, the CPU will run ~MOV A,R0~, (aka it will "move" the accumulator value to "Register 0").

** ASM

Now, we don't want to write bytecode by hand in hexadecimal, for that we will use the [[https://shop-pdp.net/ashtml/asxxxx.php][asxxxx]] assembler.

We start with some boilerplate for the assembler.

#+begin_src asm
        .ifdef  .__.CPU. ; if we are using as8048 this is defined
        .8041
        .area   CODE    (ABS)
        .endif           ; .__.CPU.
#+end_src

CPU starts reading at address zero (0x0). We put there a jump to where is our program. Skipping some reserve addresss for other operations.

#+begin_src asm
        .org 0x0
reset:
        jmp entry
#+end_src

Our main program startes here.

#+begin_src asm
        .org 0x10
entry:
        mov  A,    #0x0A ; 00001010
        outl P2,   A
        call delay

        mov  A,    #0x15 ; 00010101
        outl P2,   A
        call delay

        jmp  entry       ; repeat main loop
#+end_src

Finally the definition of ~delay~. Basically 2 nested loops with ~nop~ on it's deepest level.

#+begin_src asm
delay:  mov  R0, #255   ; init outer loop counter
delay2: mov  R1, #255   ; init inner loop counter
delay1:
        nop
        nop
        nop
        nop
        djnz R1, delay1 ; dec inner count, continue if not zero
        djnz R0, delay2 ; dec outer count, continue if not zero
        ret             ; return to caller
#+end_src

That's it!

** The ROM output

Ok, long story short, I copied this makefile [[https://github.com/retiredfeline/8042-clock/blob/master/Makefile][elsewhere]] to build the .bin image I want.

#+begin_src makefile
default: blink.bin

# assemble with as8048
%.hex: %.asm
	as8048 -l -o $<
	aslink -i -o $(<:.asm=.rel)

# convert to bin
%.bin: %.hex
	hex2bin -p 00 -e bin $<
#+end_src

This outputs something like this

#+CAPTION: output of *hd* on blink.rom
#+begin_src
  00000000  04 10 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
  00000010  23 0a 3a 14 1c 23 15 3a  14 1c 04 10 b8 ff b9 ff  |#.:..#.:........|
  00000020  00 00 00 00 e9 20 e8 1e  83 00 00 00 00 00 00 00  |..... ..........|
  00000030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
  *
  000003f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 9e  |................|
  00000400
#+end_src


Now we could write this .rom to our EEPROM with a programmer.

* Testing

aka Confirming the CPU is doing what is supposed to do

** The Setup

My testing setup consists on 2 additional parts.

- I use the *SS* (Single Step) input pin on the 8042. That allows me to use a momentary button to advance one instruction at the time. Instead of going at the speed of the clock. This button needs to be debounced, I used a 555 for that.
- I use the trick Ben Eater used for his 6502 series. And that is use an Arduino as some sort of digital analyzer. I use it to monitor what is on the DATA and ADDRESS bus as I Single Step.

** Failure and ...

So here is the image.

#+begin_src sh
$ xxd blink.rom
00000000: 1535 0410 0000 0000 0000 0000 0000 0000  .5..............
00000010: 235f 3a14 1c23 af3a 141c 0410 b955 b863  #_:..#.:.....U.c
00000020: 0000 e820 e91e 8300 0000 0000 0000 0000  ... ............
00000030: 0000 0000 0000 0000 0000 0000 0000 0000  ................
...
#+end_src

And here is some ~Serial~ debug output with the address, data in hexadecimal, and data in hexadecimal and binary.

#+begin_src sh
0000: 1a 0001 1010
0001: 3a 0011 1010
0002: 08 0000 1000
0003: 10 0001 0000
#+end_src

We start at address 0x00, and we advance one byte at the time. That seems good.

#+begin_src sh
0010: 23 0010 0011
0011: 5f 0101 1111
0012: 35 0011 0101
#+end_src

Woah there, we jumped to address 10 (?). Oh right, the ~jmp entry~.

#+begin_src sh
07ff: 00 0000 0000
#+end_src

Ok, some random (?) reading.

#+begin_src sh
0013: 18 0001 1000
0014: 1c 0001 1100
001c: b6 1011 0110
001d: 5a 0101 1010
001e: b4 1011 0100
001f: 63 0110 0011
#+end_src

Wait something is wrong here. The second nibble of data is not always matching the expected data in memory.

For example the first reading, was:

#+begin_src sh
0000: 1a
#+end_src

But it should have been:

#+begin_src sh
0000: 15
#+end_src

Let's check the cables....yup..I got the wiring of this improvised sniffer wrong. Fixing...

But before that let's see a bit more.

#+begin_src sh
0020: 00
0021: 00
0022: e4 1110 0100
0023: 20 0010 0000
0020: 00
0021: 00
0022: e4
0023: 20
#+end_src

Ok, we are looping.

Some wiring fixes and it +worked+ blinked!.

* Future Work

I want do more with this. I was asked: *"What is the difference between the 8042 and the Z80?"*. And honestly all I can talk is about specs.

- No RAM expansion.
- Poor instruction set.

But what does this REALLY mean?.

Let's try run something more "real" on it!

* Resources

A special section is dedicated to honour some of the resources I found online. There are a few more (not many). But these resulted the more useful, accurate and "modern". Two of these resources went offline while writting this blog entry ... so before I bitrot myself, here are the waybackmachine links:

- [[https://www.controller-designs.de/index.php?lang=de&cat=projekte&cont=demon48_128k&sub=documentation_2][mcs-48 detailed overview]]
- project: [[https://hackaday.io/project/161909-8042-clock][8041 clock]]
- project: [[http://web.archive.org/web/20250321054243/http://devster.monkeeh.com/z80/upi42/][8041 leds]]
  - wirings & code to output for Port1 and Port2 with 74xxx latch
- project: [[http://web.archive.org/web/20251229173918/https://www.mattmillman.com/projects/an-intel-mcs-48-based-dual-temperature-sensor/][8048 temperature sensor]]
  - [[https://github.com/inaxeon/mcs48temp/blob/upimaster/main.asm][upimaster/main.asm]]
  - [[https://github.com/inaxeon/mcs48temp/blob/upislave/main.asm][upislave/main.asm]]
  - [[https://github.com/inaxeon/mcs48temp/blob/master/main.asm][master/main.asm]]
